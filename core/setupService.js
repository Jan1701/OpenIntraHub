// =====================================================
// Setup Service - Web Installer Backend Logic
// =====================================================

const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const { Pool } = require('pg');
const Redis = require('ioredis');
const { hashPassword } = require('./auth');
const { createModuleLogger } = require('./logger');

const logger = createModuleLogger('Setup');

const SETUP_LOCK_FILE = path.join(__dirname, '..', '.setup-lock');
const ENV_FILE = path.join(__dirname, '..', '.env');
const ENV_EXAMPLE_FILE = path.join(__dirname, '..', '.env.example');

/**
 * Check if setup is already completed
 */
async function isSetupCompleted() {
    try {
        await fs.access(SETUP_LOCK_FILE);
        return true;
    } catch {
        return false;
    }
}

/**
 * Create setup lock file
 */
async function createSetupLock() {
    const lockData = {
        completed_at: new Date().toISOString(),
        version: require('../package.json').version
    };
    await fs.writeFile(SETUP_LOCK_FILE, JSON.stringify(lockData, null, 2));
    logger.info('Setup lock file created');
}

/**
 * Generate secure random string
 */
function generateSecureSecret(length = 64) {
    return crypto.randomBytes(length).toString('hex');
}

/**
 * Test database connection
 */
async function testDatabaseConnection(config) {
    let pool = null;
    try {
        pool = new Pool({
            host: config.host,
            port: parseInt(config.port) || 5432,
            database: config.database,
            user: config.user,
            password: config.password,
            connectionTimeoutMillis: 5000
        });

        const result = await pool.query('SELECT NOW(), version()');

        return {
            success: true,
            message: 'Database connection successful',
            version: result.rows[0].version,
            timestamp: result.rows[0].now
        };
    } catch (error) {
        logger.error('Database connection test failed', { error: error.message });
        return {
            success: false,
            message: error.message,
            code: error.code
        };
    } finally {
        if (pool) {
            await pool.end();
        }
    }
}

/**
 * Test Redis connection
 */
async function testRedisConnection(config) {
    let redis = null;
    try {
        redis = new Redis({
            host: config.host,
            port: parseInt(config.port) || 6379,
            password: config.password || undefined,
            connectionName: 'setup-test',
            connectTimeout: 5000,
            retryStrategy: () => null // Don't retry
        });

        await redis.ping();
        const info = await redis.info('server');

        return {
            success: true,
            message: 'Redis connection successful',
            info: info
        };
    } catch (error) {
        logger.error('Redis connection test failed', { error: error.message });
        return {
            success: false,
            message: error.message
        };
    } finally {
        if (redis) {
            redis.disconnect();
        }
    }
}

/**
 * Test LDAP connection (basic)
 */
async function testLdapConnection(config) {
    // Basic validation only - full test would require ldapjs
    if (!config.url || !config.searchBase) {
        return {
            success: false,
            message: 'LDAP URL and Search Base are required'
        };
    }

    return {
        success: true,
        message: 'LDAP configuration validated (connection test skipped in setup)',
        note: 'Full LDAP test will be performed on first login'
    };
}

/**
 * Test Exchange connection
 */
async function testExchangeConnection(config) {
    try {
        const exchangeService = require('./exchangeService');

        if (!config.server_url || !config.username || !config.password) {
            return {
                success: false,
                message: 'Exchange server URL, username, and password are required'
            };
        }

        // Test connection using Exchange service
        const result = await exchangeService.testConnection({
            server_url: config.server_url,
            username: config.username,
            password: config.password,
            auth_type: config.auth_type || 'basic'
        });

        return result;
    } catch (error) {
        logger.error('Exchange connection test failed', { error: error.message });
        return {
            success: false,
            message: error.message
        };
    }
}

/**
 * Write .env file
 */
async function writeEnvFile(config) {
    const envLines = [];

    // App Config
    envLines.push('# =====================================================');
    envLines.push('# OpenIntraHub Configuration');
    envLines.push('# Generated by Web Installer');
    envLines.push(`# Date: ${new Date().toISOString()}`);
    envLines.push('# =====================================================');
    envLines.push('');
    envLines.push('# Application');
    envLines.push(`NODE_ENV=${config.nodeEnv || 'production'}`);
    envLines.push(`PORT=${config.port || 3000}`);
    envLines.push(`FRONTEND_URL=${config.frontendUrl || 'http://localhost:3000'}`);
    envLines.push('');

    // JWT
    envLines.push('# JWT Authentication');
    envLines.push(`JWT_SECRET=${config.jwtSecret || generateSecureSecret()}`);
    envLines.push(`JWT_EXPIRES_IN=${config.jwtExpiresIn || '24h'}`);
    envLines.push('');

    // Database
    envLines.push('# PostgreSQL Database');
    envLines.push(`DB_HOST=${config.database.host}`);
    envLines.push(`DB_PORT=${config.database.port || 5432}`);
    envLines.push(`DB_NAME=${config.database.database}`);
    envLines.push(`DB_USER=${config.database.user}`);
    envLines.push(`DB_PASSWORD=${config.database.password}`);
    envLines.push(`DB_SSL=${config.database.ssl ? 'true' : 'false'}`);
    envLines.push('');

    // Redis
    if (config.redis?.enabled) {
        envLines.push('# Redis Cache');
        envLines.push(`REDIS_HOST=${config.redis.host}`);
        envLines.push(`REDIS_PORT=${config.redis.port || 6379}`);
        if (config.redis.password) {
            envLines.push(`REDIS_PASSWORD=${config.redis.password}`);
        }
        envLines.push('');
    }

    // LDAP
    if (config.ldap?.enabled) {
        envLines.push('# LDAP/Active Directory');
        envLines.push('LDAP_ENABLED=true');
        envLines.push(`LDAP_URL=${config.ldap.url}`);
        envLines.push(`LDAP_BIND_DN=${config.ldap.bindDn || ''}`);
        envLines.push(`LDAP_BIND_PASSWORD=${config.ldap.bindPassword || ''}`);
        envLines.push(`LDAP_SEARCH_BASE=${config.ldap.searchBase}`);
        envLines.push(`LDAP_SEARCH_FILTER=${config.ldap.searchFilter || '(uid={{username}})'}`);
        envLines.push('');
    } else {
        envLines.push('# LDAP/Active Directory');
        envLines.push('LDAP_ENABLED=false');
        envLines.push('');
    }

    // Email
    if (config.email?.enabled) {
        envLines.push('# Email / SMTP');
        envLines.push(`SMTP_HOST=${config.email.host}`);
        envLines.push(`SMTP_PORT=${config.email.port || 587}`);
        envLines.push(`SMTP_SECURE=${config.email.secure ? 'true' : 'false'}`);
        envLines.push(`SMTP_USER=${config.email.user || ''}`);
        envLines.push(`SMTP_PASSWORD=${config.email.password || ''}`);
        envLines.push(`SMTP_FROM=${config.email.from || 'noreply@openintrahub.local'}`);
        envLines.push('');
    }

    // Exchange
    if (config.exchange?.enabled) {
        envLines.push('# Exchange Calendar Sync');
        envLines.push('EXCHANGE_ENABLED=true');
        envLines.push(`EXCHANGE_DEFAULT_SERVER=${config.exchange.server_url || ''}`);
        envLines.push(`EXCHANGE_DEFAULT_AUTH_TYPE=${config.exchange.auth_type || 'basic'}`);
        envLines.push('');
    }

    // Exchange encryption key (always generate for security)
    envLines.push('# Exchange Encryption Key (for storing credentials)');
    const crypto = require('crypto');
    envLines.push(`EXCHANGE_ENCRYPTION_KEY=${crypto.randomBytes(32).toString('hex')}`);
    envLines.push('');

    // Logging
    envLines.push('# Logging');
    envLines.push(`LOG_LEVEL=${config.logLevel || 'info'}`);
    envLines.push('');

    // Write file
    await fs.writeFile(ENV_FILE, envLines.join('\n'));
    logger.info('.env file created successfully');

    return {
        success: true,
        path: ENV_FILE
    };
}

/**
 * Run database migrations
 */
async function runDatabaseMigrations(dbConfig) {
    const pool = new Pool({
        host: dbConfig.host,
        port: parseInt(dbConfig.port) || 5432,
        database: dbConfig.database,
        user: dbConfig.user,
        password: dbConfig.password
    });

    try {
        // Get all migration files
        const migrationsDir = path.join(__dirname, '..', 'db', 'migrations');
        const files = await fs.readdir(migrationsDir);
        const sqlFiles = files.filter(f => f.endsWith('.sql')).sort();

        logger.info(`Found ${sqlFiles.length} migration files`);

        // Create migrations tracking table
        await pool.query(`
            CREATE TABLE IF NOT EXISTS schema_migrations (
                id SERIAL PRIMARY KEY,
                filename VARCHAR(255) NOT NULL UNIQUE,
                executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Get already executed migrations
        const executedResult = await pool.query('SELECT filename FROM schema_migrations');
        const executed = new Set(executedResult.rows.map(r => r.filename));

        const results = [];

        // Execute pending migrations
        for (const file of sqlFiles) {
            if (executed.has(file)) {
                logger.debug(`Migration ${file} already executed, skipping`);
                results.push({ file, status: 'skipped' });
                continue;
            }

            logger.info(`Executing migration: ${file}`);
            const filePath = path.join(migrationsDir, file);
            const sql = await fs.readFile(filePath, 'utf8');

            try {
                await pool.query(sql);
                await pool.query(
                    'INSERT INTO schema_migrations (filename) VALUES ($1)',
                    [file]
                );
                logger.info(`Migration ${file} executed successfully`);
                results.push({ file, status: 'success' });
            } catch (error) {
                logger.error(`Migration ${file} failed`, { error: error.message });
                results.push({ file, status: 'error', error: error.message });
                throw error; // Stop on first error
            }
        }

        return {
            success: true,
            executed: results.filter(r => r.status === 'success').length,
            skipped: results.filter(r => r.status === 'skipped').length,
            results
        };
    } catch (error) {
        logger.error('Database migration failed', { error: error.message });
        throw error;
    } finally {
        await pool.end();
    }
}

/**
 * Create admin user
 */
async function createAdminUser(dbConfig, userData) {
    const pool = new Pool({
        host: dbConfig.host,
        port: parseInt(dbConfig.port) || 5432,
        database: dbConfig.database,
        user: dbConfig.user,
        password: dbConfig.password
    });

    try {
        // Check if admin already exists
        const existing = await pool.query(
            'SELECT id FROM users WHERE username = $1 OR email = $2',
            [userData.username, userData.email]
        );

        if (existing.rows.length > 0) {
            return {
                success: false,
                message: 'User with this username or email already exists'
            };
        }

        // Hash password
        const passwordHash = await hashPassword(userData.password);

        // Create admin user
        const result = await pool.query(`
            INSERT INTO users (username, email, name, password_hash, role, is_active, is_verified)
            VALUES ($1, $2, $3, $4, 'admin', true, true)
            RETURNING id, username, email, name, role
        `, [userData.username, userData.email, userData.name, passwordHash]);

        logger.info('Admin user created', { username: userData.username });

        return {
            success: true,
            user: result.rows[0]
        };
    } catch (error) {
        logger.error('Admin user creation failed', { error: error.message });
        return {
            success: false,
            message: error.message
        };
    } finally {
        await pool.end();
    }
}

/**
 * System requirements check
 */
async function checkSystemRequirements() {
    const checks = {
        node: {
            name: 'Node.js Version',
            required: '>=18.0.0',
            current: process.version,
            status: 'ok'
        },
        writeable: {
            name: 'Filesystem Write Access',
            status: 'checking'
        },
        memory: {
            name: 'Available Memory',
            current: Math.round(require('os').totalmem() / 1024 / 1024) + ' MB',
            recommended: '2048 MB',
            status: 'ok'
        }
    };

    // Check if we can write .env
    try {
        await fs.access(path.join(__dirname, '..'), fs.constants.W_OK);
        checks.writeable.status = 'ok';
        checks.writeable.message = 'Can write to application directory';
    } catch {
        checks.writeable.status = 'error';
        checks.writeable.message = 'Cannot write to application directory';
    }

    return checks;
}

module.exports = {
    isSetupCompleted,
    createSetupLock,
    generateSecureSecret,
    testDatabaseConnection,
    testRedisConnection,
    testLdapConnection,
    testExchangeConnection,
    writeEnvFile,
    runDatabaseMigrations,
    createAdminUser,
    checkSystemRequirements
};
